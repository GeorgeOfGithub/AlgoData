## 1.1
26-59-41-31
41-59
58-59

## 1.2
for i = n-1 to 0
j=i
while j<n-1 and a[j+1] > a[j]
    swap a[j] and a[j+1]
    j=j+1

## 1.3
det vil være ligesom hvis det man søger efter er i midten af arrayet som værende den gennemsnitlige placering

## 1.4

## 1.5
Det giver mening da man sorterer arrayet ind i mindre og mindre dele indtil man nærmest bare laver byt 2 pladser

## 1.6
Man kunne bruge det til at sorterer rekursivt ved at splitte arrayet op i mindre bidder

## 2.1
Den skal sorteres og dernæst kører man igennem array og kigger på naboer

## 2.2

## 2.3

## 3

## 4

## 5.1
Man kigger på hver sum 1 efter 1 og ser om et af alle de andre tal plusset på det bestemte tal giver 0

## 5.2
At sortere noget tager n*log(n) tid
Man kigger på et tal og så laver binary search efter det tal som man skal finde.

## 5.3
Man kigger på hvert tal og leder nu igennem alle de andre tal og kigger efter 2 tal som giver 0 tilsammen med de andre

## 5.4
Samme koncept som 5.2, Sorteret array og så kigger man efter A[i] og A[j] og så ved man hvad A[k] som man leder efter skal være

## 5.5
Find et tal og så find en 2-sum ved at kigge fra start og slut og gående imod midten og kigge efter en 2-sum. 

## 6.1