## 1
2^n, n^3, n^2, n, n*log n, sqrt(n)
## 2
n^3
2^n
n*sqrt(n)
n
sqrt(n)
n
2^n
n^3 * log(n)
n^2
n^3 log(n)

## 3
log2 n = O(log n)
log5 n = O(log n)
n*log2 n = O(n log n)


## 4
no
yes
no
no
yes
yes
yes
yes
no
no



## 5.1
2^3 = 8 gange langsommere

## 5.2
5+15=20
20+25=45
45+35=80
80+45=125
125+55=180

n^2/200000=O(n^2)

## 5.3
3*log2(n)

## 6.1
Fordi de begge er non-negative betyder det at de begge er theta-notation. Når man så kigger på den største af dem betyder det så at man igen kigger på theta af dem.

## 6.2
Fordi O-notation er det størst mulige tid som man bruger kan man ikke sige at det skal være mindst det længste tid. Det ville være mere rigtigt at sige "at most"

## 6.3
2^n+1 = O(2^n) true
2^2n = O(2^2n) false

## 6.4
log(x!) er mindre end x log(x) og dermed passer O-notationen

## 6.5
hvis man ganger med en konstant bliver den mindre end log(x!) dermed passer theta-notation

![6.5] (week 3.png)

## 7.1 
fordi de allerede er blevet sorteret betyder det at man bare skal køre to merges ved hver arrayplacering. derfor er det 2*n som så bliver til O(n)

## 7.2
3-merge vil have samme O notation som 2 merge. den eneste forskel vil være at det er log3 (n) og ikke log2 (n) og når dette skrives ind i o-notation bliver det bare log (n)

## 7.3
det vil ikke være bedre at bruge et k-merge end et 2-merge da log kun ændrer sig og dette betyder ikke noget for o-notation.

## 8.1
Man sorterer først arrayet med merge sort og så lægger alle sammen som er efter den sidste negative værdi og dermed lægger man alle positive sammen og dermed får man maximal

## 8.2
-II-

## 8.3















